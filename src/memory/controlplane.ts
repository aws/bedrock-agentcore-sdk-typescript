import {
  BedrockAgentCoreControlClient,
  CreateMemoryCommand,
  GetMemoryCommand,
  ListMemoriesCommand,
  UpdateMemoryCommand,
  DeleteMemoryCommand,
} from '@aws-sdk/client-bedrock-agentcore-control'

import { MemoryStatus, DEFAULT_REGION, DEFAULT_MAX_WAIT, DEFAULT_POLL_INTERVAL } from './constants.js'
import type {
  MemoryControlPlaneClientConfig,
  CreateMemoryParams,
  StrategyConfig,
  NormalizedMemory,
  WaitOptions,
  ModifyStrategyInput,
} from './types.js'

/**
 * Client for Bedrock AgentCore Memory control plane operations.
 *
 * Use this for memory resource management when you don't need data plane operations.
 * For full functionality including events and memory retrieval, use MemoryClient instead.
 */
export class MemoryControlPlaneClient {
  private readonly _client: BedrockAgentCoreControlClient
  readonly region: string

  constructor(config: MemoryControlPlaneClientConfig = {}) {
    this.region = config.region ?? process.env.AWS_REGION ?? DEFAULT_REGION

    this._client = new BedrockAgentCoreControlClient({
      region: this.region,
      ...(config.credentialsProvider && { credentials: config.credentialsProvider }),
    })
  }

  // ========== Memory Operations ==========

  async createMemory(params: CreateMemoryParams): Promise<NormalizedMemory> {
    const { name, strategies, description, eventExpiryDays, memoryExecutionRoleArn } = params

    const commandParams: any = {
      name,
    }

    if (strategies) {
      commandParams.strategies = strategies
    }

    if (description) {
      commandParams.description = description
    }

    if (eventExpiryDays) {
      commandParams.eventExpiryDuration = eventExpiryDays
    }

    if (memoryExecutionRoleArn) {
      commandParams.memoryExecutionRoleArn = memoryExecutionRoleArn
    }

    const response = await this._client.send(new CreateMemoryCommand(commandParams))
    return this._normalizeMemoryResponse(response.memory as any)
  }

  async getMemory(memoryId: string, includeStrategies: boolean = true): Promise<NormalizedMemory> {
    const response = await this._client.send(
      new GetMemoryCommand({
        memoryId,
        includeStrategies,
      } as any)
    )
    return this._normalizeMemoryResponse(response.memory as any)
  }

  async listMemories(maxResults: number = 100): Promise<NormalizedMemory[]> {
    const memories: NormalizedMemory[] = []
    let nextToken: string | undefined

    do {
      const response = await this._client.send(
        new ListMemoriesCommand({
          maxResults,
          nextToken,
        })
      )

      if (response.memories) {
        memories.push(...response.memories.map((m) => this._normalizeMemoryResponse(m as any)))
      }
      nextToken = response.nextToken
    } while (nextToken)

    return memories
  }

  async updateMemory(params: {
    memoryId: string
    description?: string
    eventExpiryDuration?: number
  }): Promise<NormalizedMemory> {
    const { memoryId, description, eventExpiryDuration } = params
    const commandParams: any = {
      memoryId,
    }

    if (description) {
      commandParams.description = description
    }

    if (eventExpiryDuration) {
      commandParams.eventExpiryDuration = eventExpiryDuration
    }

    const response = await this._client.send(new UpdateMemoryCommand(commandParams))
    return this._normalizeMemoryResponse(response.memory as any)
  }

  async deleteMemory(memoryId: string): Promise<void> {
    await this._client.send(new DeleteMemoryCommand({ memoryId }))
  }

  // ========== Strategy Operations ==========

  async addStrategy(
    memoryId: string,
    strategy: StrategyConfig,
    options?: WaitOptions
  ): Promise<NormalizedMemory> {
    const { maxWait = DEFAULT_MAX_WAIT, pollInterval = DEFAULT_POLL_INTERVAL } = options || {}

    const response = await this._client.send(
      new UpdateMemoryCommand({
        memoryId,
        addStrategies: [strategy],
      } as any)
    )

    const memory = this._normalizeMemoryResponse(response.memory as any)

    // Wait for strategy to become active if requested
    // We need to find the strategy ID from the response or wait for memory to be active
    // Since we don't know the new strategy ID easily without parsing, we can wait for memory active
    // But wait, the response should contain the updated memory with strategies.
    // However, the strategy ID is generated by the service.
    // Let's wait for the memory to be ACTIVE which implies strategies are processed.

    if (maxWait > 0) {
      return this._waitForMemoryActive(memoryId, maxWait, pollInterval)
    }

    return memory
  }

  async getStrategy(memoryId: string, strategyId: string): Promise<Record<string, unknown>> {
    const memory = await this.getMemory(memoryId, true)
    const strategy = memory.strategies?.find((s) => s.strategyId === strategyId)

    if (!strategy) {
      throw new Error(`Strategy ${strategyId} not found in memory ${memoryId}`)
    }

    return strategy as unknown as Record<string, unknown>
  }

  async updateStrategy(params: {
    memoryId: string
    strategyId: string
    description?: string
    namespaces?: string[]
    configuration?: Record<string, unknown>
  }): Promise<NormalizedMemory> {
    const { memoryId, strategyId, description, namespaces, configuration } = params

    const modifyStrategy: ModifyStrategyInput = {
      memoryStrategyId: strategyId,
      ...(description && { description }),
      ...(namespaces && { namespaces }),
      ...(configuration && { configuration }),
    }

    const response = await this._client.send(
      new UpdateMemoryCommand({
        memoryId,
        modifyStrategies: [modifyStrategy],
      } as any)
    )

    return this._normalizeMemoryResponse(response.memory as any)
  }

  async removeStrategy(
    memoryId: string,
    strategyId: string,
    options?: WaitOptions
  ): Promise<NormalizedMemory> {
    const { maxWait = DEFAULT_MAX_WAIT, pollInterval = DEFAULT_POLL_INTERVAL } = options || {}

    const response = await this._client.send(
      new UpdateMemoryCommand({
        memoryId,
        deleteStrategyIds: [strategyId],
      } as any)
    )

    if (maxWait > 0) {
      return this._waitForMemoryActive(memoryId, maxWait, pollInterval)
    }

    return this._normalizeMemoryResponse(response.memory as any)
  }

  // ========== Helper Methods ==========

  private _normalizeMemoryResponse(memory: any): NormalizedMemory {
    // Handle both old and new field names
    const normalized: NormalizedMemory = {
      ...memory,
      id: memory.id || memory.memoryId,
      name: memory.name,
      status: memory.status,
      strategies: [],
    }

    // Normalize strategies
    const strategies = memory.strategies || memory.memoryStrategies || []
    normalized.strategies = strategies.map((s: any) => ({
      ...s,
      strategyId: s.strategyId || s.memoryStrategyId,
      type: s.type || s.memoryStrategyType,
    }))

    return normalized
  }

  private async _waitForMemoryActive(
    memoryId: string,
    maxWait: number,
    pollInterval: number
  ): Promise<NormalizedMemory> {
    const startTime = Date.now()
    while (Date.now() - startTime < maxWait * 1000) {
      const memory = await this.getMemory(memoryId)
      if (memory.status === MemoryStatus.ACTIVE) {
        return memory
      }
      if (memory.status === MemoryStatus.FAILED) {
        throw new Error(`Memory ${memoryId} failed: ${memory.failureReason}`)
      }
      await new Promise((resolve) => setTimeout(resolve, pollInterval * 1000))
    }
    throw new Error(`Timeout waiting for memory ${memoryId} to become ACTIVE`)
  }
}
